package main

import (
	"fmt"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strings"

	"github.com/sourcegraph/log"
	"github.com/sourcegraph/run"
	"github.com/sourcegraph/sourcegraph/lib/errors"
	"github.com/urfave/cli/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/vektah/gqlparser/v2/parser"

	"github.com/sourcegraph/src-api-demo/internal/observability"
	"github.com/sourcegraph/src-api-demo/internal/output"
)

func main() {
	liblog := observability.InitLogs("gen", "dev")
	defer liblog.Sync()

	sort.Sort(cli.CommandsByName(gen.Commands))
	sort.Sort(cli.FlagsByName(gen.Flags))

	if err := gen.Run(os.Args); err != nil {
		_ = output.Render(output.FormatText, err)
		os.Exit(1)
	}
}

var gen = &cli.App{
	Name:  "gen",
	Usage: "gen is a CLI tool to generate Sourcegraph GraphQL Go client",
	Flags: []cli.Flag{
		&cli.StringFlag{
			Name:  "version",
			Usage: "The ref of the Sourcegraph application to generate GraphQL schema, e.g., tag, commit SHA, or branch name",
			Value: "main",
		},
		&cli.BoolFlag{
			Name:  "dotcom",
			Usage: "Regenerate the dotcom GraphQL schema from version",
		},
		// this is useful in bazel where all generator can share the same repo cache
		&cli.StringFlag{
			Name:  "archive.path",
			Usage: "The path to the repository archive to generate the schema from. version flag is ignored if this is set",
		},
		// only use in bazel to avoid injecting go toolchain into sandbox
		&cli.BoolFlag{
			Name:  "schema-only",
			Usage: "Only generate the schema files, do not generate genql client",
		},
	},
	Action: func(c *cli.Context) error {
		logger := log.Scoped("gen").With(log.String("version", c.String("version")))

		cwd, err := os.Getwd()
		if err != nil {
			return errors.Wrap(err, "failed to get current working directory")
		}

		tmpDir, err := os.MkdirTemp("", "srcgql-")
		if err != nil {
			return errors.Wrap(err, "failed to get user cache dir")
		}
		defer func() {
			_ = os.RemoveAll(tmpDir)
		}()

		version := c.String("version")
		repoDir := filepath.Join(tmpDir, fmt.Sprintf("sourcegraph-%s", version))

		if err := os.MkdirAll(repoDir, 0755); err != nil {
			return errors.Wrap(err, "failed to create repo dir")
		}

		archivePath := c.String("archive.path")
		if archivePath == "" {
			archivePath = filepath.Join(tmpDir, fmt.Sprintf("sourcegraph-%s.tar.gz", version))
			logger.Info("downloading archive for version", log.String("archivePath", archivePath))
			if err := downloadFile(archivePath, fmt.Sprintf("https://github.com/sourcegraph/sourcegraph/archive/%s.tar.gz", version)); err != nil {
				return errors.Wrap(err, "failed to download archive")
			}
		}

		ctx := observability.LogCommands(c.Context, logger)
		// we use bsdtar instead of tar to avoid occasional "tar: dir: Directory renamed before its status could be extracted"
		if err := run.Cmd(ctx, "bsdtar", "-xzf", archivePath, "-C", repoDir, "--strip-components=1").Run().Wait(); err != nil {
			return errors.Wrap(err, "failed to extract archive")
		}

		var graphqlFiles, dotcomGraphqlFiles []string
		if err := filepath.WalkDir(repoDir, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if d.IsDir() {
				return nil
			}
			if filepath.Ext(path) != ".graphql" {
				return nil
			}

			logger := logger.With(log.String("path", path))
			logger.Debug("found graphql schema file")

			// ignore any query/mutation files, they are not schema
			bytes, err := os.ReadFile(path)
			if err != nil {
				return errors.Wrapf(err, "read graphql file: %q", path)
			}
			if _, err := parser.ParseSchema(&ast.Source{Name: path, Input: string(bytes)}); err != nil {
				if _, err := parser.ParseQuery(&ast.Source{Name: path, Input: string(bytes)}); err == nil {
					logger.Info("found graphql query file not schema file, skipping")
					return nil
				} else {
					return errors.Wrapf(err, "graphql file %q is neither a schema nor a query file", path)
				}
			}

			if strings.HasSuffix(path, "dotcom.graphql") {
				// track dotcom files separately
				dotcomGraphqlFiles = append(dotcomGraphqlFiles, path)
			} else {
				graphqlFiles = append(graphqlFiles, path)
			}

			return nil
		}); err != nil {
			return errors.Wrap(err, "walk graphql files")
		}
		if len(graphqlFiles) == 0 {
			return errors.New("no graphql schema files found")
		}

		logger.Debug("concatenating graphql schema files")
		schemas := map[string][]string{
			"src.schema.graphql": graphqlFiles,
		}
		if c.Bool("dotcom") {
			schemas["dotcom.schema.graphql"] = dotcomGraphqlFiles
		}
		for dst, fileSet := range schemas {
			slices.Sort(fileSet)
			var output []byte
			output = append([]byte("# GENERATED BY srcgql. DO NOT EDIT.\n\n"), output...)
			for _, g := range fileSet {
				d, err := os.ReadFile(g)
				if err != nil {
					return errors.Wrap(err, "read graphql schema file")
				}
				output = append(output, d...)
			}
			if err := os.WriteFile(filepath.Join(cwd, dst), output, 0644); err != nil {
				return errors.Wrap(err, "write graphql schema file")
			}
		}

		if !c.Bool("schema-only") {
			if err := run.Cmd(ctx, "go", "run", "github.com/Khan/genqlient", "genqlient.yaml").Run().Stream(os.Stdout); err != nil {
				return errors.Wrap(err, "failed to generate client")
			}
		}
		return nil
	},
}

func downloadFile(filepath string, url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return errors.Newf("failed to download file: %s", resp.Status)
	}

	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	return err
}
